import "dart:async";
import "dart:collection";

import "package:analyzer/dart/element/element.dart";
import "package:analyzer/dart/element/element2.dart";
import "package:build/build.dart";
import "package:code_builder/code_builder.dart";
import "package:dart_style/dart_style.dart";
import "package:glob/glob.dart";

import "package:gql_code_builder/serializer.dart";
import "package:path/path.dart" as p;

import "./allocators/pick_allocator.dart";
import "./config.dart";

/// Aggregates all `built_value` `Serializers` generated by any of the gql builders.
class SerializerBuilder implements Builder {
  final AssetId schemaId;
  final Set<Reference> customSerializers;
  final Map<String, Reference> typeOverrides;

  SerializerBuilder(
    this.schemaId,
    this.customSerializers,
    this.typeOverrides,
  );

  static final _formatter =
      DartFormatter(languageVersion: DartFormatter.latestLanguageVersion);
  static final _generatedFiles = Glob("lib/**.gql.dart");

  // create a path for the serializers output in same directory as schema
  List<String> get pathSegments =>
      outputAssetId(schemaId, serializerExtension).pathSegments
        ..removeLast()
        ..add("serializers.gql.dart");

  @override
  Map<String, List<String>> get buildExtensions => {
        // buildExtensions already include the 'lib' path segment, so we must remove it here
        r"$lib$": [p.joinAll(pathSegments.skip(1))],
      };

  @override
  FutureOr<void> build(BuildStep buildStep) async {
    /// BuiltValue classes with serializers. These will be added automatically
    /// using `@SerializersFor`.
    final builtClasses =
        SplayTreeSet<ClassElement2>((a, b) => a.name3!.compareTo(b.name3!));

    /// Non BuiltValue classes with serializers (i.e. inline fragment classes).
    /// These need to be added manually since `@SerializersFor` only recognizes
    /// BuiltValue classes.
    final nonBuiltClasses =
        SplayTreeSet<ClassElement2>((a, b) => a.name3!.compareTo(b.name3!));

    final hasSerializer = (ClassElement2 c) => c.fields2.any((field) =>
        field.isStatic &&
        field.name3 == "serializer" &&
        field.type.element3?.name3 == "Serializer" &&
        field.type.element3?.library2?.uri.toString() ==
            "package:built_value/serializer.dart");

    final isBuiltValue = (ClassElement2 c) => c.allSupertypes.any((interface) =>
        (interface.element3.name3 == "Built" ||
            interface.element3.name3 == "EnumClass") &&
        interface.element3.library2.uri.toString() ==
            "package:built_value/built_value.dart");

    await for (final input in buildStep.findAssets(_generatedFiles)) {
      final lib = await buildStep.resolver.libraryFor(input);
      lib.classes
          .where((c) => hasSerializer(c) && isBuiltValue(c))
          .forEach(builtClasses.add);

      lib.classes
          .where(
            (c) => hasSerializer(c) && !isBuiltValue(c),
          )
          .forEach(nonBuiltClasses.add);
    }

    // Collect URIs for non-built classes to ensure they can be imported if needed
    final nonBuiltClassUris = nonBuiltClasses
        .map((c) => c.library2.uri.toString())
        .whereType<String>()
        .toSet();

    // Initialize allocator *after* collecting all necessary URIs
    final allocator = PickAllocator(
      doNotPick: ["package:built_value/serializer.dart"],
      // Convert the set of includes to a list
      include: {
        // Ensure built_collection is included for ListBuilder serializers
        "package:built_collection/built_collection.dart",
        // Include user-defined type overrides
        ...typeOverrides.values.map((ref) => ref.url).whereType<String>(),
        // Include sources of non-built classes used in built_value classes
        ...nonBuiltClassUris,
      }.toList(), // Convert the Set to a List
    );

    final Set<Expression> additionalSerializers = {
      // GraphQL Operation serializer
      refer(
        "OperationSerializer",
        "package:gql_code_builder_serializers/gql_code_builder_serializers.dart",
      ).call([]),
      // User-defined custom serializers
      ...customSerializers.map((ref) => ref.call([])),
      // Serializers from data classes that aren't caught by `@SerializersFor`
      ...nonBuiltClasses.map<Expression>(
        (c) =>
            refer(c.name3!, c.library2.uri.toString()).property("serializer"),
      ),
    };

    final library = buildSerializerLibrary(
      builtClasses,
      "serializers.gql.g.dart",
      additionalSerializers,
    );

    final _emitter = DartEmitter(
      allocator: allocator,
      orderDirectives: true,
      useNullSafetySyntax: true,
    );

    final output = AssetId(
      buildStep.inputId.package,
      p.joinAll(pathSegments),
    );

    return buildStep.writeAsString(
      output,
      _formatter.format("${library.accept(_emitter)}"),
    );
  }
}
